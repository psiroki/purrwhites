<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PurrWhites</title>
    <meta name="description" content="PurrWhites: for perfectly pure whites in your images, with super customizable tweaks to make 'em pop. Get those whites spot-on with this app!">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="PurrWhites">
    <meta name="twitter:description" content="PurrWhites: for perfectly pure whites in your images, with super customizable tweaks to make 'em pop. Get those whites spot-on with this app!">
    <meta name="twitter:image" content="https://psiroki.github.io/purrwhites/pw.png">
    <meta property="og:title" content="PurrWhites">
    <meta property="og:description" content="PurrWhites: for perfectly pure whites in your images, with super customizable tweaks to make 'em pop. Get those whites spot-on with this app!">
    <meta property="og:image" content="https://psiroki.github.io/purrwhites/pw.png">
    <meta property="og:type" content="website">
    <link rel="icon" href="https://psiroki.github.io/purrwhites/favicon.ico" type="image/x-icon">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons&text=image,content_paste" rel="stylesheet">
    <style>
        .material-icons { font-family: 'Material Icons'; font-size: 24px; }
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            max-height: 100vh;
            max-width: 100vw;
            margin: 0;
        }
        canvas {
            box-shadow: 0 0 3px #ccc;
        }
        input[type=color] {
            min-width: 28px;
        }
        .controls, .save-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            height: 48px;
        }
        .save-controls {
            height: 32px;
        }
        .checkbox-label {
            cursor: pointer;
            display: none; /* Hidden but accessible via console */
        }
        .sample-rect {
            position: absolute;
            border: 2px solid red;
            pointer-events: none;
            box-sizing: border-box;
            display: none;
        }
        input[type="file"] {
            display: none;
        }
        input {
            vertical-align: middle;
            position: relative;
            top: -1px;
        }
        button, .simple-button {
            cursor: pointer;
            padding: 5px 10px;
            background-color: #f0f0f0;
            border-radius: 4px;
            white-space: nowrap;
            border: none;
            user-select: none;
            -webkit-user-select: none;
            height: 38px;
            box-sizing: border-box;
            color: #111;
        }
        .simple-button:hover {
            background-color: #e0e0e0;
        }
        .slider-value {
            min-width: 40px;
            text-align: right;
        }
        .multiplier-input {
            width: 42px;
        }
        .control-label {
            white-space: nowrap;
        }
        #canvasContainer {
            overflow: hidden;
            user-select: none;
            touch-action: none;
            max-width: 100vw;
        }
        #canvasContainer > * {
            transform-origin: 0 0;
        }
        /* Touch devices: horizontal scrolling */
        @media (pointer: coarse) {
            .controls, .save-controls {
                flex-wrap: nowrap;
                overflow-x: auto;
                overflow-y: hidden;
                width: 100%;
                padding: 4px; /* Space for scrollbar */
            }
        }
    </style>
</head>
<body>
    <div class="controls">
        <label for="fileInput" class="simple-button"><span class="material-icons">image</span></label>
        <input type="file" id="fileInput" accept="image/*">
        <button id="pasteImage" class="simple-button"><span class="material-icons">content_paste</span></button>
        <button type="button" id="compareButton" class="simple-button">&#x25ef;</button>
        <input type="color" id="colorPicker" value="#ffffff">
        <label for="scalar" class="control-label">Multiplier: <input type="number" id="scalar" value="1.0" min="0.0" step="0.1" class="multiplier-input"></label>
        <label for="sampleSize" class="control-label">Sample Size: <span id="sampleSizeValue" class="slider-value">3</span> <input type="range" id="sampleSize" min="1" max="50" value="3"></label>
        <label class="checkbox-label"><input type="checkbox" id="linearColorSpace" checked="checked"> Use Linear Color Space</label>
    </div>
    <div class="save-controls">
        <button id="savePng">PNG</button>
        <button id="saveJpeg">JPEG</button>
        <label for="jpegQuality" class="control-label">Quality: <input type="range" id="jpegQuality" min="0" max="1" step="0.01" value="0.8"><span id="jpegQualityValue" class="slider-value">0.80</span></label>
    </div>
    <div id="canvasContainer"></div>
    <div id="sampleRect" class="sample-rect"></div>

    <script type="module">
        import { ImageProcessor } from './ImageProcessor.js';
        import { crc32 } from './crc32.js';
        import { ScrollZoom } from './ui/scrollzoom.js';

        let processor = null;
        let scrollZoom = null;
        let isMouseDown = false;
        let lastMultiplier = [1, 1, 1];

        async function loadImage(file) {
            // Destroy existing processor and remove canvas
            if (processor) {
                processor.canvas.remove();
                processor = null;
            }
            if (scrollZoom) {
                scrollZoom.detach();
                scrollZoom = null;
            }

            // Create new ImageBitmap
            const imageBitmap = await createImageBitmap(file);

            // Initialize new ImageProcessor
            processor = new ImageProcessor(imageBitmap, document.getElementById('linearColorSpace').checked);
            const view = document.getElementById('canvasContainer');
            view.appendChild(processor.canvas);
            scrollZoom = new ScrollZoom(view);
            scrollZoom.clickHandler = e => {
                handleSample(e);
                setTimeout(hideSampleRect, 200);
            };

            // Re-attach mouse event listeners
            attachMouseListeners();
            updateSampleSize();
            updateMultiplierFromColorPicker();
        }

        function attachMouseListeners() {
            processor.canvas.addEventListener('mousedown', handleSample);
            processor.canvas.addEventListener('mousemove', handleSample);
            processor.canvas.addEventListener('mouseup', hideSampleRect);
        }

        // Function to convert sRGB to linear color space
        function srgbToLinear(color) {
            return Math.pow(color, 2.2);
        }

        // Function to update multiplier
        function updateMultiplier(r, g, b) {
            const scalar = parseFloat(document.getElementById('scalar').value);
            if (isNaN(scalar)) {
                return; // Don't update if scalar is not a valid number
            }

            // Convert to linear color space if enabled
            const useLinearColorSpace = document.getElementById('linearColorSpace').checked;
            const rLinear = useLinearColorSpace ? srgbToLinear(r) : r;
            const gLinear = useLinearColorSpace ? srgbToLinear(g) : g;
            const bLinear = useLinearColorSpace ? srgbToLinear(b) : b;

            // Calculate multiplier: [s, (r/g)*s, (r/b)*s]
            const multiplier = [
                scalar,
                gLinear !== 0 ? (rLinear / gLinear) * scalar : scalar, // Avoid division by zero
                bLinear !== 0 ? (rLinear / bLinear) * scalar : scalar
            ];
            lastMultiplier = multiplier;

            // Update ImageProcessor multiplier
            processor.setMultiplier(multiplier);
        }

        // Function to update multiplier from color picker
        function updateMultiplierFromColorPicker() {
            // Convert hex color to RGB (0-1 range)
            const hex = document.getElementById('colorPicker').value.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16) / 255;
            const g = parseInt(hex.substring(2, 4), 16) / 255;
            const b = parseInt(hex.substring(4, 6), 16) / 255;
            updateMultiplier(r, g, b);
        }

        // Function to update multiplier from sample
        function updateMultiplierFromSample(sample, keepScalar) {
            // Update color picker to reflect sampled color
            const rHex = Math.round(sample.r * 255).toString(16).padStart(2, '0');
            const gHex = Math.round(sample.g * 255).toString(16).padStart(2, '0');
            const bHex = Math.round(sample.b * 255).toString(16).padStart(2, '0');
            document.getElementById('colorPicker').value = `#${rHex}${gHex}${bHex}`;

            if (!keepScalar) {
                    // Update scalar to 1/linearRed or 1/red based on color space
                const useLinearColorSpace = document.getElementById('linearColorSpace').checked;
                const redValue = useLinearColorSpace ? srgbToLinear(sample.r) : sample.r;
                const scalar = redValue !== 0 ? 1 / redValue : 1.0;
                document.getElementById('scalar').value = scalar.toFixed(3); // Limit to 3 decimal places for readability
            }

            // Update multiplier with sampled color
            updateMultiplier(sample.r, sample.g, sample.b);
        }

        // Function to update linear color space
        function updateLinearColorSpace() {
            if (processor) {
                processor.setLinearColorSpace(document.getElementById('linearColorSpace').checked);
            }
        }

        // Function to update sample size
        function updateSampleSize() {
            if (processor) {
                const size = parseInt(document.getElementById('sampleSize').value);
                if (!isNaN(size) && size > 0) {
                    processor.setSampleSize(size);
                    // Update sample rectangle size
                    const sampleRect = document.getElementById('sampleRect');
                    sampleRect.style.width = `${size}px`;
                    sampleRect.style.height = `${size}px`;
                    // Update displayed sample size value
                    document.getElementById('sampleSizeValue').textContent = size.toString().padStart(2, "\u2007");
                }
            }
        }

        // Function to update JPEG quality display
        function updateJpegQualityDisplay() {
            const quality = parseFloat(document.getElementById('jpegQuality').value);
            document.getElementById('jpegQualityValue').textContent = quality.toFixed(2);
        }

        // Function to handle sampling
        function handleSample(event) {
            // Only handle left-click (button 0)
            if (event.button !== 0 && event.type === 'mousedown') {
                return;
            }
            if (event.type === 'mousedown') {
                isMouseDown = true;
            }
            if (!isMouseDown && event.type === 'mousemove') {
                return;
            }

            const naturalWidth = processor.canvas.offsetWidth;
            const naturalHeight = processor.canvas.offsetHeight;
            const rect = processor.canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left) / rect.width;
            const y = (event.clientY - rect.top) / rect.height;
            if (x < 0 || x >= 1 || y < 0 || y >= 1) {
                return;
            }
            const sample = processor.sampleRegion(x * naturalWidth, y * naturalHeight);
            updateMultiplierFromSample(sample, event.shiftKey);

            // Update sample rectangle position
            const zoom = scrollZoom ? scrollZoom.viewMatrix[0] : 1;
            const sampleSize = parseInt(document.getElementById('sampleSize').value)*zoom;
            const sampleRect = document.getElementById('sampleRect');
            sampleRect.style.display = 'block';
            sampleRect.style.left = `${event.clientX - sampleSize / 2}px`;
            sampleRect.style.top = `${event.clientY - sampleSize / 2}px`;
            sampleRect.style.width = `${sampleSize}px`;
            sampleRect.style.height = `${sampleSize}px`;
        }

        function hideSampleRect() {
            isMouseDown = false;
            document.getElementById('sampleRect').style.display = 'none';
        }

        // Detect iOS/iPadOS
        function isAppleMobileDevice() {
            const userAgent = navigator.userAgent || navigator.platform || '';
            const platform = navigator.platform || '';
            const isIOS = /iPhone|iPad|iPod/.test(userAgent) || 
                         /iPhone|iPad|iPod/.test(platform) ||
                         (userAgent.includes('Macintosh') && navigator.maxTouchPoints > 2);
            return isIOS;
        }

        // Centralized function to save image
        async function saveImage(mimeType, quality = 1.0) {
            if (!processor) return;

            const dataUrl = processor.canvas.toDataURL(mimeType, quality);
            // Convert data URL to Uint8Array
            const base64 = dataUrl.split(',')[1];
            const binary = atob(base64);
            const fileContents = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                fileContents[i] = binary.charCodeAt(i);
            }
            // Generate filename with CRC32 hash
            const hash = crc32(fileContents);
            const extension = mimeType.split('/').at(1);
            const filename = `image_${hash}.${extension}`;
            const file = new File([fileContents], filename, { type: mimeType });

            if (isAppleMobileDevice() && navigator.canShare && navigator.canShare({ files: [file] })) {
                try {
                    return await navigator.share({
                        files: [file],
                        title: "Processed image",
                        text: filename
                    });
                } catch (e) {
                    console.error("Share sheet error, falling back to download link", e);
                }
            }
            const link = document.createElement('a');
            link.download = filename;
            link.href = dataUrl;
            link.click();
        }

        // Image loading via file input
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file && file.type && file.type.startsWith('image/')) {
                await loadImage(file);
            }
        });

        // Image loading via drag-and-drop
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });
        document.addEventListener('drop', async (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file && file.type && file.type.startsWith('image/')) {
                await loadImage(file);
            }
        });

        // Image loading via paste
        document.addEventListener('paste', async (e) => {
            const file = e.clipboardData.files[0];
            if (file && file.type && file.type.startsWith('image/')) {
                await loadImage(file);
            }
        });

        document.getElementById('pasteImage').addEventListener('click', async (e) => {
            // Request clipboard read permission and get clipboard items
            const clipboardItems = await navigator.clipboard.read();
            
            // Find the first item with an image type (e.g., image/png, image/jpeg)
            for (const item of clipboardItems) {
                const imageTypes = item.types.filter(type => type.startsWith('image/'));
                if (imageTypes.length > 0) {
                    // Get the blob for the first image type
                    const blob = await item.getType(imageTypes[0]);
                    
                    await loadImage(blob);
                    break; // Process only the first image
                }
            }
        });

        // Image saving
        document.getElementById('savePng').addEventListener('click', () => {
            saveImage('image/png');
        });

        document.getElementById('saveJpeg').addEventListener('click', () => {
            const quality = parseFloat(document.getElementById('jpegQuality').value);
            saveImage('image/jpeg', quality);
        });

        // Add event listener for JPEG quality slider
        document.getElementById('jpegQuality').addEventListener('input', updateJpegQualityDisplay);

        (button => {
            button.addEventListener("pointerdown", e => {
                if (e.isPrimary) {
                    processor.setMultiplier([1, 1, 1]);
                    e.currentTarget.setPointerCapture(e.pointerId);
                }
            });
            const release = e => {
                if (e.isPrimary) {
                    processor.setMultiplier(lastMultiplier);
                    e.currentTarget.releasePointerCapture(e.pointerId);
                }
            };
            button.addEventListener("pointerup", release);
            button.addEventListener("pointercancel", release);
            button.addEventListener("pointerout", release);
            button.addEventListener("pointerleave", release);
        })(document.getElementById('compareButton'));

        // Initial image load
        async function init() {
            try {
                const response = await fetch('offwhite.jpeg');
                const blob = await response.blob();
                await loadImage(blob);
            } catch (error) {
                console.error('Initial image load failed:', error);
            }

            // Add event listeners for controls
            document.getElementById('colorPicker').addEventListener('input', updateMultiplierFromColorPicker);
            document.getElementById('scalar').addEventListener('input', updateMultiplierFromColorPicker);
            document.getElementById('sampleSize').addEventListener('input', updateSampleSize);
            document.getElementById('linearColorSpace').addEventListener('input', updateLinearColorSpace);

            // Initialize slider value displays
            updateSampleSize();
            updateJpegQualityDisplay();
        }

        // Run initialization
        init();
    </script>
</body>
</html>
